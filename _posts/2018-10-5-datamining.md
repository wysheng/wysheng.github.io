---
layout: post
title:  "Louvain 社团发现算法学习"
date:   2018-10-5 15:45:28
categories: 机器学习 
tags:  机器学习 推荐算法  数据挖掘
---
* content
{:toc}
## 算法介绍：

Louvain 算法是基于模块度的社区发现算法，该算法在效率和效果上都表现较好，并且能够发现层次性的社区结构，其优化目标是最大化整个社区网络的模块度。

社区网络的模块度（Modularity）是评估一个社区网络划分好坏的度量方法，它的含义是社区内节点的连边数与随机情况下的边数之差，它的取值范围是 (0,1)，其定义如下：
![](https://img-blog.csdn.net/20170414185610724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE1NDcyNzY1NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
上式中，Aij代表结点i和j之间的边权值（当图不带权时，边权值可以看成1）。 ki代表结点i的領街边的边权和（当图不带权时，即为结点的度数）。
m为图中所有边的边权和。 ci为结点i所在的社团编号。
模块度的公式定义可以做如下的简化：
![](https://img-blog.csdn.net/20170414193226025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE1NDcyNzY1NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
其中Sigma in表示社区c内的边的权重之和，Sigma tot表示与社区c内的节点相连的边的权重之和。
我们的目标，是要找出各个结点处于哪一个社团，并且让这个划分结构的模块度最大。
Louvain算法的思想很简单：

1）将图中的每个节点看成一个独立的社区，次数社区的数目与节点个数相同；
2）对每个节点i，依次尝试把节点i分配到其每个邻居节点所在的社区，计算分配前与分配后的模块度变化Delta Q，并记录Delta Q最大的那个邻居节点，如果maxDelta Q>0，则把节点i分配Delta Q最大的那个邻居节点所在的社区，否则保持不变；
3）重复2），直到所有节点的所属社区不再变化；
4）对图进行压缩，将所有在同一个社区的节点压缩成一个新节点，社区内节点之间的边的权重转化为新节点的环的权重，社区间的边权重转化为新节点间的边权重；
5）重复1）直到整个图的模块度不再发生变化。
在写代码时，要注意几个要点：

* 第二步，尝试分配结点时，并不是只尝试独立的结点，也可以尝试所在社区的结点数大于1的点，我在看paper时一开始把这个部分看错了，导致算法出问题。

* 第三步，重复2）的时候，并不是将每个点遍历一次后就对图进行一次重构，而是要不断循环的遍历每个结点，直到一次循环中所有结点所在社区都不更新了，表示当前网络已经稳定，然后才进行图的重构。

* 模块度增益的计算，请继续看下文
--------------------- 
过程如下图所示：
![](https://img-blog.csdn.net/20170414195729001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE1NDcyNzY1NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
可以看出，louvain是一个启发式的贪心算法。我们需要对模块度进行一个启发式的更新。这样的话这个算法会有如下几个问题：

1：尝试将节点i分配到相邻社团时，如果真的移动结点i，重新计算模块度，那么算法的效率很难得到保证

2：在本问题中，贪心算法只能保证局部最优，而不能够保证全局最优

3：将节点i尝试分配至相邻社团时，要依据一个什么样的顺序

......
第一个问题，在该算法的paper中给了我们解答。我们实际上不用真的把节点i加入相邻社团后重新计算模块度，paper中给了我们一个计算把结点i移动至社团c时，模块度的增益公式：
--------------------- 
![](https://img-blog.csdn.net/20170414194703112?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE1NDcyNzY1NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
其中Sigma in表示起点终点都在社区c内的边的权重之和，Sigma tot表示入射社区c内的边的权重之和，ki代表结点i的带权度数和，m为所有边权和。

但是该增益公式还是过于复杂，仍然会影响算法的时间效率。 

但是请注意，我们只是想通过模块增益度来判断一个结点i是否能移动到社团c中，而我们实际上是没有必要真正的去求精确的模块度，只需要知道，当前的这步操作，模块度是否发生了增长。

因此，就有了相对增益公式的出现：

![](https://img-blog.csdn.net/20170414200159913?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE1NDcyNzY1NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
相对增益的值可能大于1，不是真正的模块度增长值，但是它的正负表示了当前的操作是否增加了模块度。用该公式能大大降低算法的时间复杂度。
第二个问题，该算法的确不能够保证全局最优。但是我们该算法的启发式规则很合理，因此我们能够得到一个十分精确的近似结果。
同时，为了校准结果，我们可以以不同的序列多次调用该算法，保留一个模块度最大的最优结果。
第三个问题，在第二个问题中也出现了，就是给某个结点i找寻領接点时，应当以一个什么顺序？递增or随机or其它规则？我想这个问题需要用实验数据去分析。

在paper中也有提到一些能够使结果更精确的序列。我的思路是，如果要尝试多次取其最优，取随机序列应该是比较稳定比较精确的方式。



说了这么多，下面给上本人的Louvain算法java实现供参考。 本人代码注释比较多，适合学习。

我的代码后面是国外大牛的代码，时空复杂度和我的代码一样，但是常数比我小很多，速度要快很多，而且答案更精准（迭代了10次），适合实际运用~
## 文章原文及代码：
[原文](https://blog.csdn.net/qq547276542/article/details/70175157)

